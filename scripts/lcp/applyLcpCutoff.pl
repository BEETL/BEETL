#!/usr/bin/env perl

=head1 LICENSE

Copyright (c) 2011-2014 Illumina, Inc.

This file is part of the BEETL software package,
covered by the "BSD 2-Clause License" (see accompanying LICENSE file)

Citation: Markus J. Bauer, Anthony J. Cox and Giovanna Rosone
Lightweight BWT Construction for Very Large String Collections.
Proceedings of CPM 2011, pp.219-231


=head1 NAME

applyLcpCutoff.pl

=head1 DIAGNOSTICS

=head2 Exit status

0: successful completion
1: abnormal completion
2: fatal error

=head2 Errors

All error messages are prefixed with "ERROR: ".

=head2 Warnings

All warning messages generated by EAGLE are prefixed with "WARNING: ".

=head1 CONFIGURATION AND ENVIRONMENT

=back

=head1 BUGS AND LIMITATIONS

There are no known bugs in this module.

All documented features are fully implemented.

Please report problems to Illumina Technical Support (support@illumina.com)

Patches are welcome.

=head1 AUTHOR

Lilian Janin

=cut

use warnings FATAL => 'all';
use strict;
use Cwd qw(abs_path);
use POSIX qw(strftime);
use IO::File;
use Carp;

use Pod::Usage;
use Getopt::Long;


my $VERSION = '1.0';

my $programName = (File::Spec->splitpath(abs_path($0)))[2];
my $programPath = (File::Spec->splitpath(abs_path($0)))[1];
my $Version_text =
    "$programName $VERSION\n"
  . "Copyright (c) 2011 Illumina\n"
  . "This source file is covered by the \"Illumina Public Source License\"\n"
  . "agreement and bound by the terms therein.\n";

my $usage =
    "Usage: $programName [options]\n"
  . "\t-q, --qualities=PATH           Input quality file (string of chars)\n"
  . "\t-b, --bwt=PATH                 Input BWT file (ASCII)\n"
  . "\t-l, --lcp=PATH                 Input LCP file (string of 32-bit integers)\n"
  . "\t-o, --output=PATH              Output file\n"

  . "\t-c, --lcp-cutoff=int32         LCP cutoff threshold. Default=0\n"
  . "\t-s, --min-stretch-length=int32 Minimum stretch length. Default=5\n"
  . "\t-r, --replacement=int8         Char used when LCP is above or equal to the cutoff threshold. Default=255\n"

  . "\t--help                         Prints usage guide\n"
  . "\t--version                      Prints version information\n"

.<<'DESCRIPTION_EXAMPLES_END';

Description:
    Cuts off qualities from stretches of lcp>=lcpThreshold with constant BWT letter.
    Also cuts off qualities from stretches broken by a change of BWT letter, as long as the stretch length is longer than minStretchLength.
    '$' BWT letters don't interrupt stretches.

Example:
    $programName \
      -q BWT/bwt.part1.qual \
      -b BWT/bwt.part1 \
      -l BWT/bwt.part1.lcp \
      -o newBWT/bwt.part1.qual

DESCRIPTION_EXAMPLES_END



my $help = 'nohelp';

my $isVersion = 0;
my %PARAMS = ();

my $argvStr = join ' ', @ARGV;

$PARAMS{verbose} = 0;

$PARAMS{qualities} = undef;
$PARAMS{lcp}    = undef;
$PARAMS{bwt}    = undef;
$PARAMS{output} = undef;
my $cutoff      = 0;
my $minStretchLength = 5;
my $replacement = 255;


my $result = GetOptions(
    "qualities|q=s"         => \$PARAMS{qualities},
    "lcp|l=s"               => \$PARAMS{lcp},
    "bwt|b=s"               => \$PARAMS{bwt},
    "output|o=s"            => \$PARAMS{output},
    "lcp-cutoff|c=i"        => \${cutoff},
    "min-stretch-length|s=i"=> \${minStretchLength},
    "replacement|r=i"       => \${replacement},

    "version"               => \$isVersion,
    "help"                  => \$help
);

# display the version info
if ($isVersion)
{
    print $Version_text;
    exit (0);
}

# display the help text when no output directory or other required options are given
if (($result == 0 || !defined($PARAMS{qualities}) || !defined($PARAMS{lcp}) || !defined($PARAMS{bwt}) || !defined($PARAMS{output}) || !defined(${cutoff}) || !defined(${minStretchLength}) || !defined(${replacement}) ) && 'nohelp' eq $help)
{
    die "$usage";
}

die ("ERROR: Unrecognized command-line argument(s): @ARGV") if (0 < @ARGV);


my $packedReplacement = pack('C', $replacement);
my $stretchLength = 0;
my $stretchBwtLetter = "\$";
my $savedQualityStretch = "";
my $brokenStretchCount = 0;
my $successfulStretchCount = 0;
my $cutoffQualitiesCount = 0;
my $lcpValue = 0;
my $lastLcpValueReached = 0;

# Those should be command line parameters
my $outputDiscardedQualities = 1;
#my $keepQ2 = 1;


my $myInt8 = "";
my $myInt32 = "";
my $int8Qual = "";
my $int8BwtLetter = "";
open INF_QUAL , "<$PARAMS{qualities}" or die "Can't open $PARAMS{qualities}";
open INF_LCP  , "<$PARAMS{lcp}"    or die "Can't open $PARAMS{lcp}";
open INF_BWT  , "<$PARAMS{bwt}"    or die "Can't open $PARAMS{bwt}";
open OUTF_QUAL, ">$PARAMS{output}" or die "Can't open $PARAMS{output} for writing";
binmode INF_QUAL;
binmode INF_LCP;
binmode INF_BWT;
binmode OUTF_QUAL;
if ($outputDiscardedQualities) {
  open OUTF_DISCARDED_QUAL, ">$PARAMS{output}.discarded" or die "Can't open $PARAMS{output}.discarded for writing";
  open OUTF_DISCARDED_QUAL_LENGTHS, ">$PARAMS{output}.discarded.lengths" or die "Can't open $PARAMS{output}.discarded.lengths for writing";
}


read (INF_LCP, $myInt32, 4); # Skip the first LCP value, as it is meaningless


while (1) {

  read (INF_QUAL, $int8Qual, 1) or last;
#  my $qualValue = unpack ('C', $int8Qual);

  if ($cutoff > 0) { # We don't need to read the LCP file if the cutoff threshold is 0
    if (read (INF_LCP, $myInt32, 4)) {
      $lcpValue = unpack ('L', $myInt32);
    } else {
      # We expect to reach the end of the LCP file exactly 1 iteration before the other files, as we skipped the first value
      ($lastLcpValueReached == 0) or die "LCP file should be exactly 4 times as long as the main qualities file";
      $lastLcpValueReached = 1;
    }
  }

  read (INF_BWT, $int8BwtLetter, 1) or last;
#  my $bwtValue = unpack ('C', $int8BwtLetter);

# lcp_v1: cut off qualities from stretches of lcp>=lcpThreshold with BWT letter constant
# lcp_v2: same as lcp_v1, but also cut off qualities from stretches broken by a change of BWT letter, as long as the stretch length is longer than minStretchLength
# lcp_v3: lcp_v2 + continue stretches when interrupted by a '$' BWT letter
# lcp_v4: keep Q2 even if they get cutoff (but they still contribute to stretches)


  if ($lcpValue >= $cutoff) {
    if ($stretchLength == 0) {
      # A new stretch is starting
      $stretchBwtLetter = $int8BwtLetter;
      $stretchLength = 1;
      $savedQualityStretch = $int8Qual;
    } else {
      # Handle the case where a stretch started with BWT letter '$'
      if ($stretchBwtLetter eq '\$') {
        $stretchBwtLetter = $int8BwtLetter;
      }
      if ($int8BwtLetter eq $stretchBwtLetter || $int8BwtLetter eq '\$') {
        # Current stretch is continuing
        $stretchLength++;
      } else {
        # Current stretch broke because BWT letter changed
        if ($stretchLength >= $minStretchLength) {
          for (my $i=0; $i<$stretchLength; $i++) {
#            if ($keepQ2 && ord(substr($savedQualityStretch,$i,1))==(33+2) ) {
#              print OUTF_QUAL chr(33+2)
#            } else {
              print OUTF_QUAL $packedReplacement;
#            }
          }
          $successfulStretchCount++;
          $cutoffQualitiesCount += $stretchLength;
          if ($outputDiscardedQualities) {
            print OUTF_DISCARDED_QUAL $savedQualityStretch;
            print OUTF_DISCARDED_QUAL_LENGTHS "${stretchLength}\n";
          }
        } else {
          # Print all previous qualities
          print OUTF_QUAL $savedQualityStretch;
          $brokenStretchCount++;
        }
        $stretchBwtLetter = $int8BwtLetter;
        $stretchLength = 1;
        $savedQualityStretch = "";
      }
      $savedQualityStretch .= $int8Qual;
    }
  } else {
    # Current stretch finished because LCP is below threshold
    # We just need to check what the last letter is
    my $lastLetterIsPartOfStretch = 0;
    if ($int8BwtLetter eq $stretchBwtLetter || $int8BwtLetter eq '\$' || $stretchBwtLetter eq '\$') {
      $lastLetterIsPartOfStretch = 1;
      $stretchLength++;
    }
    if ($stretchLength >= $minStretchLength) {
      for (my $i=0; $i<$stretchLength; $i++) {
        print OUTF_QUAL $packedReplacement;
      }
      $successfulStretchCount++;
      $cutoffQualitiesCount += $stretchLength;
      if ($lastLetterIsPartOfStretch == 0) {
        print OUTF_QUAL $int8Qual;
        $brokenStretchCount++;
      }
      if ($outputDiscardedQualities) {
        print OUTF_DISCARDED_QUAL $savedQualityStretch;
        print OUTF_DISCARDED_QUAL_LENGTHS "${stretchLength}\n";
      }
    }
    else {
      print OUTF_QUAL $savedQualityStretch;
      print OUTF_QUAL $int8Qual;
      $brokenStretchCount++;
    }
    $savedQualityStretch = "";
    $stretchLength = 0;
  }
}


# Final output
if ($stretchLength > 0) {
  my $i;
  for ($i=0; $i<$stretchLength; $i++) {
    print OUTF_QUAL $packedReplacement;
  }
  $successfulStretchCount++;
  $cutoffQualitiesCount += $stretchLength;
  if ($outputDiscardedQualities) {
    print OUTF_DISCARDED_QUAL $savedQualityStretch;
    print OUTF_DISCARDED_QUAL_LENGTHS "${stretchLength}\n";
  }
}


close INF_QUAL;
close INF_LCP;
close INF_BWT;
close OUTF_QUAL;
close OUTF_DISCARDED_QUAL if ($outputDiscardedQualities);
close OUTF_DISCARDED_QUAL_LENGTHS if ($outputDiscardedQualities);


# Report

print "brokenStretchCount: $brokenStretchCount\n";
print "successfulStretchCount: $successfulStretchCount\n";
print "cutoffQualitiesCount: $cutoffQualitiesCount\n";
